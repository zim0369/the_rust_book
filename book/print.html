<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> introduction                                              </a></li><li class="chapter-item expanded "><a href="quick_look.html"><strong aria-hidden="true">2.</strong> Quick Look                                                </a></li><li class="chapter-item expanded "><a href="01_getting_started.html"><strong aria-hidden="true">3.</strong> Getting Started                                           </a></li><li class="chapter-item expanded "><a href="02_programming_a_guessing_game.html"><strong aria-hidden="true">4.</strong> Programming A Guessing Game                               </a></li><li class="chapter-item expanded "><a href="03_common_programming_concepts.html"><strong aria-hidden="true">5.</strong> Common Programming Concepts                               </a></li><li class="chapter-item expanded "><a href="04_understanding_ownership.html"><strong aria-hidden="true">6.</strong> Understanding Ownership                                   </a></li><li class="chapter-item expanded "><a href="05_using_structs_to_structure_related_data.html"><strong aria-hidden="true">7.</strong> Using Structs To Structure Related Data                   </a></li><li class="chapter-item expanded "><a href="06_enums_and_pattern_matching.html"><strong aria-hidden="true">8.</strong> Enums And Pattern Matching                                </a></li><li class="chapter-item expanded "><a href="07_managing_growing_projects_with_packages_crates_and_modules.html"><strong aria-hidden="true">9.</strong> Managing Growing Projects With Packages Crates And Modules</a></li><li class="chapter-item expanded "><a href="08_common_collections.html"><strong aria-hidden="true">10.</strong> Common Collections                                        </a></li><li class="chapter-item expanded "><a href="09_error_handling.html"><strong aria-hidden="true">11.</strong> Error Handling                                            </a></li><li class="chapter-item expanded "><a href="10_generic_types_traits_and_lifetimes.html"><strong aria-hidden="true">12.</strong> Generic Types Traits And Lifetimes                        </a></li><li class="chapter-item expanded "><a href="11_writing_automated_tests.html"><strong aria-hidden="true">13.</strong> Writing Automated Tests                                   </a></li><li class="chapter-item expanded "><a href="12_an_io_project.html"><strong aria-hidden="true">14.</strong> An Io Project                                             </a></li><li class="chapter-item expanded "><a href="13_functional_language_features.html"><strong aria-hidden="true">15.</strong> Functional Language Features                              </a></li><li class="chapter-item expanded "><a href="14_more_about_cargo_and_crates.io.html"><strong aria-hidden="true">16.</strong> More About Cargo And Crates.io                            </a></li><li class="chapter-item expanded "><a href="15_smart_pointers.html"><strong aria-hidden="true">17.</strong> Smart Pointers                                            </a></li><li class="chapter-item expanded "><a href="16_fearless_concurrency.html"><strong aria-hidden="true">18.</strong> Fearless Concurrency                                      </a></li><li class="chapter-item expanded "><a href="17_object_oriented_programming_features_of_rust.html"><strong aria-hidden="true">19.</strong> Object Oriented Programming Features Of Rust              </a></li><li class="chapter-item expanded "><a href="18_patterns_and_matching.html"><strong aria-hidden="true">20.</strong> Patterns And Matching                                     </a></li><li class="chapter-item expanded "><a href="19_advanced_features.html"><strong aria-hidden="true">21.</strong> Advanced Features                                         </a></li><li class="chapter-item expanded "><a href="20_final_project.html"><strong aria-hidden="true">22.</strong> Final Project                                             </a></li><li class="chapter-item expanded "><a href="21_appendix.html"><strong aria-hidden="true">23.</strong> Appendix                                                  </a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">introduction</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-look"><a class="header" href="#quick-look">Quick Look</a></h1>
<h2 id="basic"><a class="header" href="#basic">Basic</a></h2>
<ul>
<li>Expressions returns something, statements don't.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="writing-a-program"><a class="header" href="#writing-a-program">Writing a program</a></h2>
<p>This is how a &quot;Hello Ferris!&quot; program looks like in Rust:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, Ferris!&quot;);
}
</code></pre></pre>
<p>Create a file named &quot;hello.rs&quot; and then open your terminal in that directory. Now compile your program with <code>rustc hello.rs</code> and run it with <code>./hello</code>. It will output: <code>Hello, Ferris!</code>(<strong>Ferris</strong> is the Rust programming language's unofficial mascot).</p>
<p style="text-align:center";>
<img src="images/01/cuddlyferris.svg" alt="Ferris" width="200" style="center">
</p>
<ul>
<li>
<p>In our program:</p>
<ul>
<li>
<p>we have the main function starting with <code>fn main() {</code> and ending at <code>}</code>. It takes no parameters, which is why the <code>()</code>(parentheses) are empty.</p>
</li>
<li>
<p><code>println!</code> calls a Rust macro. If it had called a function instead, it would be entered as <code>println</code> (without the !).</p>
</li>
<li>
<p>We pass this <code>&quot;Hello, Ferris!&quot;</code> as an argument to <code>println!</code>, and the string is printed to the screen.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/fmt/">Read about string formatting here</a></p>
</li>
<li>
<p>We end the line with a semicolon (<code>;</code>), which indicates that this expression is over.</p>
</li>
<li>
<p><strong>NOTE:</strong> <em>The order in which functions are written doesn't matter but macros have to appear before they are used.</em></p>
</li>
</ul>
</li>
</ul>
<h2 id="cargo"><a class="header" href="#cargo">Cargo</a></h2>
<p>Cargo is Rust's build system and package manager. We use it when we have to use any dependencies. Our previous program was simple so we did not need cargo.</p>
<ul>
<li>
<p>Let's get familiar with cargo:</p>
<ul>
<li>First make sure that cargo is installed. Try running: <code>cargo --version</code></li>
<li>Help: <code>cargo --help</code> or</li>
<li>If manpages are installed: <code>man cargo</code></li>
</ul>
</li>
<li>
<p>Creating our first cargo project:</p>
<ul>
<li>
<p>Run <code>cargo new hello_cargo</code>: This will create a new cargo project directory named <code>hello_cargo</code> which contains:</p>
<ul>
<li>&quot;<strong>Cargo.toml</strong>&quot; file is Cargo's configuration file written in TOML(Tom's Obvious, Minimal Language) format:</li>
</ul>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

[dependencies]
</code></pre>
<p>The first line, <strong>[package]</strong>, is a section heading that indicates that the following statements are configuring a package. As we add more information to this file, we’ll add other sections.</p>
<p>The next three lines set the configuration information Cargo needs to compile your program: the name, the version, and the edition of Rust to use.</p>
<p>The last line, <strong>[dependencies]</strong>, is the start of a section for you to list any of your project’s dependencies. In Rust, packages of code are referred to as crates. We won’t need any other crates for this project, but we will use it later.</p>
<ul>
<li>
<p>&quot;<strong>Cargo.lock</strong>&quot; file keeps track of the exact versions of dependencies in your project. This project doesn’t have dependencies, so the file is a bit sparse. You won’t ever need to change this file manually; Cargo manages its contents for you.</p>
</li>
<li>
<p>&quot;<strong>src/main.rs</strong>&quot;: Cargo contains a dir &quot;src&quot; for source files. The top-level project directory is just for README files, license information, configuration files, and anything else not related to your code. By default the &quot;main.rs&quot; file has:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
</li>
<li>
<p>While you are inside your Cargo project dir. You can do the following:</p>
<ul>
<li>Build(compile) our program with <code>cargo build</code></li>
<li>Run it with <code>./target/debug/hello_cargo</code></li>
<li>Or both build and run with <code>cargo run</code></li>
<li>Or just check our program for errors with <code>cargo check</code> without having to compile and or run. It just checks your code but doesn't create an executable</li>
<li>When your project is finally ready for release, you should use <code>cargo build --release</code> to compile it with optimizations. This creates an executable under <code>target/release</code> instead of <code>target/debug</code>. It is slower as compared to just <code>cargo build</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="tips"><a class="header" href="#tips">Tips</a></h2>
<p>You might come across some rusty projects on github that require you to build the project from scratch to install it for which you usually have to follow the steps similar to:</p>
<pre><code class="language-console">$ git clone example.org/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>Usually people just open an editor to edit the source code and a terminal to build the project in which case you could just use &quot;cargo-watch&quot;. It watches over your project's source for changes, and runs Cargo commands when they occur.</p>
<p>Install: <code>cargo install cargo-watch</code><br />
Use: <code>cargo watch</code>(inside the project dir)</p>
<p>Now all you have to do is edit the source code and save the file if you have to build the changes.</p>
<!-- TODO: cargo clippy -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-a-guessing-game"><a class="header" href="#programming-a-guessing-game">Programming A Guessing Game</a></h1>
<p>We’ll implement a guessing game. Here’s how it works: the program will generate a random integer between 1 and 100. It will then prompt the player to enter a guess. After a guess is entered, the program will indicate whether the guess is too low or too high. If the guess is correct, the game will print a congratulatory message and exit.</p>
<p>Create a new project dir with <code>cargo new guess</code> and now let's think how we're going to implement the core functionality, generating a random number. Here we will use the capabilities of cargo that we didn't use before. Google search &quot;<a href="https://crates.io/crates/rand"> rust crate rand </a>&quot;. This crate helps us generate random numbers. You'll find instructions there on how to add this dependency to our program. Let's do that.</p>
<p>We need to edit our &quot;Cargo.toml&quot; file to add a dependency:</p>
<p><a href="https://semver.org/">Read about semantic versioning here</a></p>
<p>Comments in TOML start with <code>#</code>(pound). The line <code>rand = &quot;0.8.4&quot;</code> adds the rand crate from <a href="https://crates.io/">crates.io</a> and any other crates <code>rand</code> requires.</p>
<p>For our game we need to:</p>
<ul>
<li>
<p>To obtain user input we need the io library with <code>use std::io</code></p>
</li>
<li>
<p>We add the line <code>use rand::Rng</code>. The <code>Rng</code> trait defines methods that random number generators implement, and this trait must be in scope for us to use those methods.</p>
</li>
<li>
<p>By default, Rust has a set of items defined in the standard library that it brings into the scope of every program. This set is called the prelude, and you can see everything in it in the standard library documentation. The io library isn't present in the prelude</p>
</li>
</ul>
<p>Filename: src/main.rs</p>
<pre><pre class="playground"><code class="language-rust">use rand::{thread_rng, Rng};
use std::cmp::Ordering::{Equal, Greater, Less};

fn main() {
    let random: u32 = thread_rng().gen_range(1..=9);
    println!(&quot;Secret number: {random}&quot;);

    loop {
        println!(&quot;Guess the number: &quot;);
        let mut guess = String::new();
        std::io::stdin().read_line(&amp;mut guess).unwrap();
        match guess.trim().parse::&lt;u32&gt;().unwrap().cmp(&amp;random) {
            Greater =&gt; println!(&quot;Too large&quot;),
            Less =&gt; println!(&quot;Too small&quot;),
            Equal =&gt; {
                println!(&quot;You won!&quot;);
                break;
            }
        }
    }
}
</code></pre></pre>
<ul>
<li>Both variables and references are immutable by default while constants are always immutable</li>
<li><code>read_line()</code> returns <code>Result</code> which is an enum type that has the variants <code>Ok</code> and <code>Err</code> and it's own methods defined on it.</li>
<li><strong>Note:</strong> You won’t just know which traits to use and which methods and functions to call from a crate, so each crate has documentation with instructions for using it. Another neat feature of Cargo is that running the cargo doc --open command will build documentation provided by all of your dependencies locally and open it in your browser. If you’re interested in other functionality in the rand crate, for example, run cargo doc --open and click rand in the sidebar on the left.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-programming-concepts"><a class="header" href="#common-programming-concepts">Common Programming Concepts</a></h1>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    println!(&quot;The value of x is: {x}&quot;);
    x = 6;
    println!(&quot;The value of x is: {x}&quot;);
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Error</summary>
<pre><code class="language-console">   Compiling l01-variables-are-immutable v0.1.0 (/home/zim/github/the_rust_book/listings/03_common_concepts/l01-variables-are-immutable)
error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:5:5
  |
3 |     let x = 5;
  |         -
  |         |
  |         first assignment to `x`
  |         help: consider making this binding mutable: `mut x`
4 |     println!(&quot;The value of x is: {x}&quot;);
5 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `l01-variables-are-immutable` due to previous error
</code></pre>
</details>
<p>The above code doesn't compile. To make it compile we'll have to make &quot;x&quot; mutable using: <code>let mut x = 5</code>.</p>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<ul>
<li>Always immutable</li>
<li>Type of the value <strong>must</strong> be annotated</li>
<li>can be declared in any scope</li>
<li>can only be set to a constant expression, not the result of a value that could only be computed at runtime. <a href="https://doc.rust-lang.org/reference/const_eval.html">Read Constant Evaluation</a>.</li>
<li>always written in uppercase and underscores are used to separate words</li>
<li>Example:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; //set to a constant expression
<span class="boring">}
</span></code></pre></pre>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>Let's not waste variable names ; )
We can even change the type of variables</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = &quot;four&quot;;

    {
        let x = x.len();
        println!(&quot;The length of string 'x' is: {x}&quot;);
    }

    println!(&quot;Five is greater than {x}&quot;);
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling l02-shadowing v0.1.0 (/home/zim/github/the_rust_book/listings/03_common_concepts/l02-shadowing)
    Finished dev [unoptimized + debuginfo] target(s) in 0.66s
     Running `target/debug/l02-shadowing`
The length of string 'x' is: 4
Five is greater than four
</code></pre>
</details>
<h2 id="datatypes"><a class="header" href="#datatypes">Datatypes</a></h2>
<ul>
<li>Rust has four primary scalar types: integers, float, boolean, and characters.</li>
<li>Length of types <code>isize</code> &amp; <code>usize</code> depends upon the underlying architecture(32bit or 64bit)</li>
<li>Each variant of an Integer type can be signed(<code>i8</code>) or unsigned(<code>u8</code>)</li>
<li>Rust’s char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII.</li>
<li>Rust's tuple type: ex- <code>let tup: (i32, f64, u8) = (500, 6.4, 1);</code></li>
<li>The tuple without any values has a special name, unit. This value and its corresponding type are both written <code>()</code> and represent an empty value or an empty return type. Expressions implicitly return the unit value if they don’t return any other value..</li>
<li>Array's in Rust are homogenous <code>let a: [i32; 5] = [1, 2, 3, 4, 5];</code></li>
<li><code>let a = [3; 5];</code> crates an array <code>[3, 3, 3, 3, 3]</code></li>
</ul>
<h2 id="invalid-array-element-access"><a class="header" href="#invalid-array-element-access">Invalid Array Element Access</a></h2>
<p>Let's say you have an array in a program with 5 elements and take user input to access a certain element. If the user inputs &quot;6&quot; to access the 6th element which isn't present in the array, Rust will panic during Run Time. This error won't be caught during compilation. Some languages let you access invalid memory but Rust doesn't. It soon panics and exits.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<ul>
<li>Type annotations for parameters are mandatory.</li>
</ul>
<!-- TODO: Add an example function that takes a variety of parameters -->
<details>
<summary>Common</summary>
<ul>
<li>
<p>Common functions</p>
<ul>
<li><code>clone()</code>:</li>
<li><code>is_ok()</code>:</li>
<li><code>is_some()</code>:</li>
<li><code>iter()</code>:</li>
<li><code>unwrap()</code>:</li>
</ul>
</li>
<li>
<p>Common macros</p>
<ul>
<li><code>format!()</code>:</li>
<li><code>panic!()</code>:</li>
</ul>
</li>
</ul>
</details>
<h2 id="statements--expressions"><a class="header" href="#statements--expressions">Statements &amp; Expressions</a></h2>
<ul>
<li>Statements are instructions that perform some action and do not return a value. Expressions evaluate to a resulting value. Let’s look at some examples.</li>
</ul>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Single line comment
/// Documentation comment
/* Multiline
   Comment */
<span class="boring">}
</span></code></pre></pre>
<h2 id="if-else"><a class="header" href="#if-else">if else</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling l03-if-else v0.1.0 (/home/zim/github/the_rust_book/listings/03_common_concepts/l03-if-else)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24s
     Running `target/debug/l03-if-else`
number is divisible by 3
</code></pre>
</details>
<h3 id="using-if-in-a-let-statement"><a class="header" href="#using-if-in-a-let-statement">Using if in a let statement</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let condition = true;
    let number = if condition { 5 } else { 6 }; //same return type

    // let number = if condition { 5 } else { &quot;six&quot; }; // incorrect

    println!(&quot;The value of number is: {number}&quot;);
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling l04-if-in-a-let-statement v0.1.0 (/home/zim/github/the_rust_book/listings/03_common_concepts/l04-if-in-a-let-statement)
    Finished dev [unoptimized + debuginfo] target(s) in 0.67s
     Running `target/debug/l04-if-in-a-let-statement`
The value of number is: 5
</code></pre>
</details>
<h2 id="repetition-with-loops"><a class="header" href="#repetition-with-loops">Repetition with loops</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2; // breaks loop and returns a value
        }
    };

    println!(&quot;The result is {result}&quot;);
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/l05-repitition-with-loops`
The result is 20
</code></pre>
</details>
<h3 id="loop-labels"><a class="header" href="#loop-labels">Loop Labels</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut count = 0;
    'counting_up: loop {
        println!(&quot;count = {count}&quot;);
        let mut remaining = 10;

        loop {
            println!(&quot;remaining = {remaining}&quot;);
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!(&quot;End count = {count}&quot;);
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/l06-loop-labels`
count = 0
remaining = 10
remaining = 9
count = 1
remaining = 10
remaining = 9
count = 2
remaining = 10
End count = 2
</code></pre>
</details>
<h3 id="while-loops"><a class="header" href="#while-loops">while Loops</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut number = 3;

    while number != 0 {
        println!(&quot;{number}!&quot;);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/l07-while-loops`
3!
2!
1!
LIFTOFF!!!
</code></pre>
</details>
<h3 id="for-loops"><a class="header" href="#for-loops">for Loops</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    for number in (1..4).chain((1..4).rev()) {
        print!(&quot;{number} &quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">    Finished dev [unoptimized + debuginfo] target(s) in 0.02s
     Running `target/debug/l08-for-loops`
1 2 3 3 2 1 
</code></pre>
</details>
<p>Notice the pattern matching on this line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// TODO: complete code
</span><span class="boring">
</span><span class="boring">// ANCHOR: all
</span><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    print!(
</span><span class="boring">        &quot;First word is: {}&quot;,
</span><span class="boring">        first_word(&amp;String::from(&quot;First word is:&quot;))
</span><span class="boring">    )
</span><span class="boring">}
</span><span class="boring">// ANCHOR_END: all
</span></code></pre></pre>
<p>In the code below:</p>
<!-- TODO: Complete code and update output -->
<p><img src="./images/03/pattern-matching.png" alt="Rust Discord Server 2" /></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// TODO: complete code
</span><span class="boring">
</span>fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

fn main() {
    print!(
        &quot;First word is: {}&quot;,
        first_word(&amp;String::from(&quot;First word is:&quot;))
    )
}
</code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/l08-02-for-loops`
First word is: 5
</code></pre>
</details>
<details>
<summary>Common</summary>
<ul>
<li>Common methods</li>
</ul>
<!-- TODO: add zip() method here -->
</details>
<h2 id="match"><a class="header" href="#match">match</a></h2>
<!-- TODO: Use "or(`|`)" inside match arms and every other possible thing -->
<h2 id="exercises"><a class="header" href="#exercises">EXERCISES</a></h2>
<ul>
<li>Convert temperatures between Fahrenheit and Celsius:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let mut temp = String::new();
    loop {
        println!(&quot;Fahrenheit(f) or Celsius(c)? &quot;);
        let mut unit = String::new();
        std::io::stdin().read_line(&amp;mut unit).unwrap();
        match unit.as_str().trim() {
            &quot;f&quot; | &quot;F&quot; =&gt; {
                println!(&quot;Enter temp in Fahrenheit:&quot;);
                std::io::stdin().read_line(&amp;mut temp).unwrap();
                let temp = temp.trim().parse::&lt;f32&gt;().unwrap();
                let temp: f32 = (temp - 32.0) * (5.0 / 9.0);
                print!(&quot;Temp in Celsius: {temp}&quot;);
                break;
            }
            &quot;c&quot; | &quot;C&quot; =&gt; {
                println!(&quot;Enter temp in Celsius:&quot;);
                std::io::stdin().read_line(&amp;mut temp).unwrap();
                let temp = temp.trim().parse::&lt;f32&gt;().unwrap();
                let temp: f32 = temp * (9.0 / 5.0) + 32.0;
                print!(&quot;Temp in Fahrenheit: {temp}&quot;);
                break;
            }
            _ =&gt; {
                continue;
            }
        }
    }
}
</code></pre></pre>
<ul>
<li>Generate the nth Fibonacci number:</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn fibox(n: u32) -&gt; u32 {
    match n {
        1 =&gt; 0,
        2 =&gt; 1,
        _ =&gt; fibox(n - 1) + fibox(n - 2),
    }
}

fn main() {
    let mut fibo = String::new();
    std::io::stdin().read_line(&amp;mut fibo).unwrap();
    let fibo = fibox(fibo.trim().parse::&lt;u32&gt;().unwrap());
    print!(&quot;{fibo}&quot;);
}
</code></pre></pre>
<ul>
<li>Print the lyrics to the Christmas carol &quot;The Twelve Days of Christmas,&quot; taking advantage of the repetition in the song.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    // 12
    let start = [
        &quot;first&quot;, &quot;second&quot;, &quot;third&quot;, &quot;fourth&quot;, &quot;fifth&quot;, &quot;sixth&quot;, &quot;seventh&quot;, &quot;eighth&quot;, &quot;ninth&quot;,
        &quot;tenth&quot;, &quot;eleventh&quot;, &quot;twelfth&quot;,
    ];
    // 11
    let mid = [
        &quot;A partridge in a pear tree&quot;,
        &quot;Two turtledoves&quot;,
        &quot;Three French hens&quot;,
        &quot;Four calling birds&quot;,
        &quot;Five gold rings (five golden rings)&quot;,
        &quot;Six geese a-laying&quot;,
        &quot;Seven swans a-swimming&quot;,
        &quot;Eight maids a-milking&quot;,
        &quot;Nine ladies dancing&quot;,
        &quot;Ten lords a-leaping&quot;,
        &quot;Eleven pipers piping&quot;,
        &quot;Twelve drummers drumming&quot;,
    ];
    for i in 0..=11 {
        println!(
            &quot;On the {} day of Christmas, my true love sent to me&quot;,
            start[i]
        );
        for j in (0..=i).rev() {
            if i != 0 &amp;&amp; j == 0 {
                print!(&quot;And &quot;);
            }
            println!(&quot;{}&quot;, mid[j]);
        }
        println!();
    }
}
</code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling l11-03-christmas v0.1.0 (/home/zim/github/the_rust_book/listings/03_common_concepts/l11-03-christmas)
    Finished dev [unoptimized + debuginfo] target(s) in 0.69s
     Running `target/debug/l11-03-christmas`
On the first day of Christmas, my true love sent to me
A partridge in a pear tree

On the second day of Christmas, my true love sent to me
Two turtledoves
And A partridge in a pear tree

On the third day of Christmas, my true love sent to me
Three French hens
Two turtledoves
And A partridge in a pear tree

On the fourth day of Christmas, my true love sent to me
Four calling birds
Three French hens
Two turtledoves
And A partridge in a pear tree

On the fifth day of Christmas, my true love sent to me
Five gold rings (five golden rings)
Four calling birds
Three French hens
Two turtledoves
And A partridge in a pear tree

On the sixth day of Christmas, my true love sent to me
Six geese a-laying
Five gold rings (five golden rings)
Four calling birds
Three French hens
Two turtledoves
And A partridge in a pear tree

On the seventh day of Christmas, my true love sent to me
Seven swans a-swimming
Six geese a-laying
Five gold rings (five golden rings)
Four calling birds
Three French hens
Two turtledoves
And A partridge in a pear tree

On the eighth day of Christmas, my true love sent to me
Eight maids a-milking
Seven swans a-swimming
Six geese a-laying
Five gold rings (five golden rings)
Four calling birds
Three French hens
Two turtledoves
And A partridge in a pear tree

On the ninth day of Christmas, my true love sent to me
Nine ladies dancing
Eight maids a-milking
Seven swans a-swimming
Six geese a-laying
Five gold rings (five golden rings)
Four calling birds
Three French hens
Two turtledoves
And A partridge in a pear tree

On the tenth day of Christmas, my true love sent to me
Ten lords a-leaping
Nine ladies dancing
Eight maids a-milking
Seven swans a-swimming
Six geese a-laying
Five gold rings (five golden rings)
Four calling birds
Three French hens
Two turtledoves
And A partridge in a pear tree

On the eleventh day of Christmas, my true love sent to me
Eleven pipers piping
Ten lords a-leaping
Nine ladies dancing
Eight maids a-milking
Seven swans a-swimming
Six geese a-laying
Five gold rings (five golden rings)
Four calling birds
Three French hens
Two turtledoves
And A partridge in a pear tree

On the twelfth day of Christmas, my true love sent to me
Twelve drummers drumming
Eleven pipers piping
Ten lords a-leaping
Nine ladies dancing
Eight maids a-milking
Seven swans a-swimming
Six geese a-laying
Five gold rings (five golden rings)
Four calling birds
Three French hens
Two turtledoves
And A partridge in a pear tree

</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-ownership"><a class="header" href="#understanding-ownership">Understanding Ownership</a></h1>
<ul>
<li>Pushing to the stack is faster than allocating on the heap</li>
<li>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there</li>
<li>When your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.</li>
<li>There can only be one owner of a value at a time</li>
<li>When owner goes out of scope, the value will be dropped</li>
</ul>
<h2 id="the-string-type"><a class="header" href="#the-string-type">The String Type</a></h2>
<ul>
<li>
<p>We use string literals(str) to store data that is known at compile time else we use the &quot;String&quot; type</p>
</li>
<li>
<p><code>String</code> can be mutated but not literals</p>
</li>
<li>
<p>With the String type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:</p>
<ul>
<li>The memory must be requested from the memory allocator at runtime.</li>
<li>We need a way of returning this memory to the allocator when we’re done with our String.</li>
<li>That first part is done by us: when we call String::from, its implementation requests the memory it needs.</li>
</ul>
</li>
<li>
<p>Common Methods</p>
<ul>
<li><code>variable.push_str(&quot;, world!&quot;);</code></li>
</ul>
<!-- TODO: Add more -->
</li>
<li>
<p>Let's look at the ways variables and data interact</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);
    let s2 = s1;
}
</code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling string-memory-representation v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/string-memory-representation)
warning: unused variable: `s2`
 --&gt; src/main.rs:6:9
  |
6 |     let s2 = s1;
  |         ^^ help: if this is intentional, prefix it with an underscore: `_s2`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: `string-memory-representation` (bin &quot;string-memory-representation&quot;) generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.56s
     Running `target/debug/string-memory-representation`
</code></pre>
</details>
<ul>
<li>This is how the memory representation looks like for:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;hello&quot;);
<span class="boring">    let s2 = s1;
</span><span class="boring">}
</span></code></pre></pre>
<p><img src="images/04/s1_heap.png" alt="s1 points to data on heap" /></p>
<ul>
<li>
<p>This is how the memory representation would look like if you clone <code>s1</code> i.e.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s2 = s1.clone()
<span class="boring">}
</span></code></pre></pre>
<p><img src="images/04/clone_s1.png" alt="s2 is a copy of s1" /></p>
</li>
<li>
<p>If the memory representation looked like below then that would be a bug. When one of the variables goes out of scope and the value is dropped, the other variable would still be pointing at that value which was dropped.</p>
<p><img src="images/04/double_free_error.png" alt="Double Free Error" /></p>
</li>
<li>
<p>The correct memory representation would like like this instead. <code>s1</code> is moved into <code>s2</code> and is no longer valid.</p>
<p><img src="images/04/moved_to_s2.png" alt="s1 moved into s2" /></p>
</li>
<li>
<p>Scalar types like <code>bool</code>, <code>u32</code>, <code>(u32, f64)</code>, etc. implement the <code>Copy</code> trait.</p>
</li>
<li>
<p>The code below works and <code>x</code> wasn't moved into <code>y</code> because the size of types like integers is known at compile time so they are stored on stack.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let x = 5;
    let y = x;

    println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling scalar-type-memory-representation v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/string-memory-representation/scalar-type-memory-representation)
    Finished dev [unoptimized + debuginfo] target(s) in 0.34s
     Running `target/debug/scalar-type-memory-representation`
x = 5, y = 5
</code></pre>
</details>
<h2 id="ownership-and-functions"><a class="header" href="#ownership-and-functions">Ownership and Functions</a></h2>
<p>The mechanics of passing a value to a function are similar to those when assigning a value to a variable.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = gives_ownership(); // gives_ownership moves its return
                                // value into s1

    let s2 = String::from(&quot;hello&quot;); // s2 comes into scope

    let s3 = takes_and_gives_back(s2); // s2 is moved into
                                       // takes_and_gives_back, which also
                                       // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing
  // happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {
    // gives_ownership will move its
    // return value into the function
    // that calls it

    let some_string = String::from(&quot;yours&quot;); // some_string comes into scope

    some_string // some_string is returned and
                // moves out to the calling
                // function
}

// This function takes a String and returns one
fn takes_and_gives_back(a_string: String) -&gt; String {
    // a_string comes into
    // scope

    a_string // a_string is returned and moves out to the calling function
}
</code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling ownership-and-functions v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/ownership-and-functions)
warning: unused variable: `s1`
 --&gt; src/main.rs:2:9
  |
2 |     let s1 = gives_ownership(); // gives_ownership moves its return
  |         ^^ help: if this is intentional, prefix it with an underscore: `_s1`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `s3`
 --&gt; src/main.rs:7:9
  |
7 |     let s3 = takes_and_gives_back(s2); // s2 is moved into
  |         ^^ help: if this is intentional, prefix it with an underscore: `_s3`

warning: `ownership-and-functions` (bin &quot;ownership-and-functions&quot;) generated 2 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 0.47s
     Running `target/debug/ownership-and-functions`
</code></pre>
</details>
<h2 id="references-and-borrowing"><a class="header" href="#references-and-borrowing">References and Borrowing</a></h2>
<ul>
<li>All references are stored on the stack. Although you can store references on
the heap, you might need another reference to refer to it. Basically, you need a
reference to refer to anything on the heap.</li>
<li>Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, it is not dropped.

</code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling references-and-borrowing v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/references-and-borrowing)
    Finished dev [unoptimized + debuginfo] target(s) in 0.44s
     Running `target/debug/references-and-borrowing`
The length of 'hello' is 5.
</code></pre>
</details>
<ul>
<li>The memory representation for the above code looks like:</li>
</ul>
<p><img src="images/04/reference.png" alt="s points to s1" /></p>
<ul>
<li>
<p>We will look at dereferencing(<code>*</code>) in later chapters <!-- TODO: Add a link to the dereference operator chapter --></p>
</li>
<li>
<p>To modify a borrowed value, make a reference mutable</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references">This Section</a> from the book marks the point of confusion</p>
</li>
<li>
<p>If you have a mutable reference to a value, you can have no other references to that value.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Error</summary>
<pre><code class="language-console">   Compiling references-and-borrowing-2 v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/references-and-borrowing-2)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `references-and-borrowing-2` due to previous error
</code></pre>
</details>
<p>The benefit of having this restriction is that Rust can prevent data races at compile time. A data race is similar to a race condition and happens when these three behaviors occur:</p>
<ul>
<li>Two or more pointers access the same data at the same time.</li>
<li>At least one of the pointers is being used to write to the data.</li>
<li>There’s no mechanism being used to synchronize access to the data.</li>
</ul>
<p>As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not simultaneous ones:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    {
        let r1 = &amp;mut s;
    } // r1 goes out of scope here, so we can make a new reference with no problems.

    let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Error</summary>
<pre><code class="language-console">   Compiling references-and-borrowing-3 v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/references-and-borrowing-3)
warning: unused variable: `r1`
 --&gt; src/main.rs:6:13
  |
6 |         let r1 = &amp;mut s;
  |             ^^ help: if this is intentional, prefix it with an underscore: `_r1`
  |
  = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `r2`
 --&gt; src/main.rs:9:9
  |
9 |     let r2 = &amp;mut s;
  |         ^^ help: if this is intentional, prefix it with an underscore: `_r2`

warning: `references-and-borrowing-3` (bin &quot;references-and-borrowing-3&quot;) generated 2 warnings
    Finished dev [unoptimized + debuginfo] target(s) in 0.58s
     Running `target/debug/references-and-borrowing-3`
</code></pre>
</details>
<p>Rust enforces a similar rule for combining mutable and immutable references.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    let r3 = &amp;mut s; // BIG PROBLEM

    println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Error</summary>
<pre><code class="language-console">   Compiling references-and-borrowing-4 v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/references-and-borrowing-4)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:7:14
  |
5 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
6 |     let r2 = &amp;s; // no problem
7 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
8 |
9 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `references-and-borrowing-4` due to previous error
</code></pre>
</details>
<p>Whew! We also cannot have a mutable reference while we have an immutable one to the same value.</p>
<p>Users of an immutable reference don’t expect the value to suddenly change out from under them! However, multiple immutable references are allowed because no one who is just reading the data has the ability to affect anyone else’s reading of the data.</p>
<p>Note that a reference’s scope starts from where it is introduced and continues through the last time that reference is used. So this code compiles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;s; // no problem
    let r2 = &amp;s; // no problem
    println!(&quot;{} and {}&quot;, r1, r2);
    // variables r1 and r2 will not be used after this point

    let r3 = &amp;mut s; // no problem
    println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling references-and-borrowing-5 v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/references-and-borrowing-5)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/references-and-borrowing-5`
hello and hello
hello
</code></pre>
</details>
<h2 id="dangling-references"><a class="header" href="#dangling-references">Dangling References</a></h2>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from(&quot;hello&quot;); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
</code></pre></pre>
<details>
<summary>Error</summary>
<pre><code class="language-console">   Compiling dangling-references v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/dangling-references)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:6:16
  |
6 | fn dangle() -&gt; &amp;String { // dangle returns a reference to a String
  |                ^ expected named lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
  |
6 | fn dangle() -&gt; &amp;'static String { // dangle returns a reference to a String
  |                 +++++++

For more information about this error, try `rustc --explain E0106`.
error: could not compile `dangling-references` due to previous error
</code></pre>
</details>
<p>Specifically:</p>
<p><mark>this function's return type contains a borrowed value, but there is no value for it to be borrowed from</mark></p>
<h2 id="slice-type-different-kind-of-references"><a class="header" href="#slice-type-different-kind-of-references">Slice Type: Different kind of references</a></h2>
<p>Let's write a program to output the first word of a string:</p>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let s = s.as_bytes();

    for (i, &amp;item) in s.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }
    s.len()
}

fn main() {
    let mut s = String::from(&quot;Get first word&quot;);
    let word = first_word(&amp;s);
    s.clear(); // word still has the value 5
    dbg!(word);
}
</code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling l01-get-first-word-index v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/l01-get-first-word-index)
    Finished dev [unoptimized + debuginfo] target(s) in 0.56s
     Running `target/debug/l01-get-first-word-index`
[src/main.rs:18] word = 3
</code></pre>
</details>
<ul>
<li>
<p>In the above program <code>word</code> still holds the value <code>3</code> which is meaningless after
the <code>String</code> gets cleared. If we use <code>word</code> further, our program will panic.</p>
</li>
<li>
<p>This can be avoided if our function returned a slice.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    for (i, &amp;item) in s.as_bytes().iter().enumerate() {
        if item == b' ' {
            return &amp;s[..i];
        }
    }
    &amp;s[..]
}

fn main() {
    let mut s = String::from(&quot;Get first word&quot;);
    let word = first_word(&amp;s);
    s.clear(); // Error!
    dbg!(word);
}
</code></pre></pre>
<details>
<summary>Error</summary>
<pre><code class="language-console">   Compiling l02-get-first-word-slice v0.1.0 (/home/zim/github/the_rust_book/listings/04_understanding_ownership/l02-get-first-word-slice)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:13:5
   |
12 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
13 |     s.clear(); // Error!
   |     ^^^^^^^^^ mutable borrow occurs here
14 |     dbg!(word);
   |          ---- immutable borrow later used here

For more information about this error, try `rustc --explain E0502`.
error: could not compile `l02-get-first-word-slice` due to previous error
</code></pre>
</details>
<ul>
<li>
<p>The above program doesn't compile</p>
</li>
<li>
<p>If we have a string slice, we can pass that directly. If we have a String, we can pass a slice of the String or a reference to the String. This flexibility takes advantage of deref coercions, a feature we will cover in the <a href="https://doc.rust-lang.org/book/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods"> &quot;Implicit Deref Coercions with Functions and Methods&quot; </a> section of Chapter 15.</p>
</li>
<li>
<p>This program can also be improved by using <code>&amp;str</code> instead of <code>&amp;String</code> in the function signature.</p>
</li>
<li>
<p>Defining a function to take a string slice instead of a reference to a String makes our API more general and useful without losing any functionality</p>
</li>
</ul>
<h3 id="other-slices"><a class="header" href="#other-slices">Other Slices</a></h3>
<p>We can use slices to refer to part of an array:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5]; // Type: &amp;[i32]

    let slice = &amp;a[1..3];

    assert_eq!(slice, &amp;[2, 3]);
    // assert_eq!(slice, [2, 3]); // Both work
}
</code></pre></pre>
<p>In the above program both <code>&amp;[2, 3]</code> and <code>[2, 3]</code> because.</p>
<p><a href="https://doc.rust-lang.org/stable/std/primitive.array.html#impl-PartialEq%3C%26%5BB%5D%3E-for-%5BA%3B%20N%5D"><img src="./images/04/partialeq.png" alt="Amanda Rust Matrix Server" /></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-structs-to-structure-related-data"><a class="header" href="#using-structs-to-structure-related-data">Using Structs To Structure Related Data</a></h1>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<ul>
<li>Structs are similar to tuples, in that both hold multiple related values.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
// We use tuple structs when we want to give names to tuples
#[derive(Debug)] // To print with dbg!
struct Scores(i32, f32, u32);

#[derive(Debug)] // To print with dbg!
struct User {
    _name: String,  // Can't use &quot;str&quot; here
    scores: Scores, // Another struct
    new: bool,
}

fn add_user(name: String, scores: Scores) -&gt; User {
    User {
        _name: name, // field init shorthand(shortens: `name: name,`)
        scores,
        new: true,
    }
}

fn main() {
    // Entire struct must be mutable. Individual fields can't be mutable.
    let mut zim = add_user(String::from(&quot;Invader Zim&quot;), Scores(0, 3.6, 9));
    let gir = User {
        _name: String::from(&quot;Gir&quot;),
        ..zim // struct update syntax.
    };
    zim.new = false; // Updating a value
    dbg!(gir.scores.2);
    // dbg!(zim.scores.2); // Error!
    dbg!(zim.new);

    // Printing an entire struct
    // println!(&quot;{:?}&quot;, gir); // cannot format with {:?}
    // println!(&quot;{gir}&quot;); // cannot format with default formatter

    dbg!(gir); // cannot format with {:?}
}
</code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling l01-structs v0.1.0 (/home/zim/github/the_rust_book/listings/05_using_structs_to_structure_related_data/l01-structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.53s
     Running `target/debug/l01-structs`
[src/main.rs:30] gir.scores.2 = 9
[src/main.rs:32] zim.new = false
[src/main.rs:38] gir = User {
    _name: &quot;Gir&quot;,
    scores: Scores(
        0,
        3.6,
        9,
    ),
    new: true,
}
</code></pre>
</details>
<ul>
<li>
<p>field <code>_name</code> is prefixed with <code>_</code> to avoid warnings because we aren't going to use it.</p>
</li>
<li>
<p>The field <code>scores</code> is a tuple struct</p>
</li>
<li>
<p>On this line the fields <code>name</code> &amp; <code>scores</code> were moved into <code>gir</code> because <code>String</code>
and <code>scores</code> do not implement the <code>Copy</code> trait:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// ANCHOR: all
</span><span class="boring">
</span><span class="boring">// We use tuple structs when we want to give names to tuples
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct Scores(i32, f32, u32);
</span><span class="boring">
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct User {
</span><span class="boring">    _name: String,  // Can't use &quot;str&quot; here
</span><span class="boring">    scores: Scores, // Another struct
</span><span class="boring">    new: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn add_user(name: String, scores: Scores) -&gt; User {
</span><span class="boring">    User {
</span><span class="boring">        _name: name, // field init shorthand(shortens: `name: name,`)
</span><span class="boring">        scores,
</span><span class="boring">        new: true,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Entire struct must be mutable. Individual fields can't be mutable.
</span><span class="boring">    let mut zim = add_user(String::from(&quot;Invader Zim&quot;), Scores(0, 3.6, 9));
</span><span class="boring">    let gir = User {
</span><span class="boring">        _name: String::from(&quot;Gir&quot;),
</span>        ..zim // struct update syntax.
<span class="boring">    };
</span><span class="boring">    zim.new = false; // Updating a value
</span><span class="boring">    dbg!(gir.scores.2);
</span><span class="boring">    // dbg!(zim.scores.2); // Error!
</span><span class="boring">    dbg!(zim.new);
</span><span class="boring">
</span><span class="boring">    // Printing an entire struct
</span><span class="boring">    // println!(&quot;{:?}&quot;, gir); // cannot format with {:?}
</span><span class="boring">    // println!(&quot;{gir}&quot;); // cannot format with default formatter
</span><span class="boring">
</span><span class="boring">    dbg!(gir); // cannot format with {:?}
</span><span class="boring">}
</span><span class="boring">// ANCHOR: all
</span></code></pre></pre>
<ul>
<li>Accessing these fields(moved) will cause an error:</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// ANCHOR: all
</span><span class="boring">
</span><span class="boring">// We use tuple structs when we want to give names to tuples
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct Scores(i32, f32, u32);
</span><span class="boring">
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct User {
</span><span class="boring">    _name: String,  // Can't use &quot;str&quot; here
</span><span class="boring">    scores: Scores, // Another struct
</span><span class="boring">    new: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn add_user(name: String, scores: Scores) -&gt; User {
</span><span class="boring">    User {
</span><span class="boring">        _name: name, // field init shorthand(shortens: `name: name,`)
</span><span class="boring">        scores,
</span><span class="boring">        new: true,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Entire struct must be mutable. Individual fields can't be mutable.
</span><span class="boring">    let mut zim = add_user(String::from(&quot;Invader Zim&quot;), Scores(0, 3.6, 9));
</span><span class="boring">    let gir = User {
</span><span class="boring">        _name: String::from(&quot;Gir&quot;),
</span><span class="boring">        ..zim // struct update syntax.
</span><span class="boring">    };
</span><span class="boring">    zim.new = false; // Updating a value
</span><span class="boring">    dbg!(gir.scores.2);
</span>    // dbg!(zim.scores.2); // Error!
<span class="boring">    dbg!(zim.new);
</span><span class="boring">
</span><span class="boring">    // Printing an entire struct
</span><span class="boring">    // println!(&quot;{:?}&quot;, gir); // cannot format with {:?}
</span><span class="boring">    // println!(&quot;{gir}&quot;); // cannot format with default formatter
</span><span class="boring">
</span><span class="boring">    dbg!(gir); // cannot format with {:?}
</span><span class="boring">}
</span><span class="boring">// ANCHOR: all
</span></code></pre></pre>
<ul>
<li>The field <code>new</code> is still valid and can be accessed.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// ANCHOR: all
</span><span class="boring">
</span><span class="boring">// We use tuple structs when we want to give names to tuples
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct Scores(i32, f32, u32);
</span><span class="boring">
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct User {
</span><span class="boring">    _name: String,  // Can't use &quot;str&quot; here
</span><span class="boring">    scores: Scores, // Another struct
</span><span class="boring">    new: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn add_user(name: String, scores: Scores) -&gt; User {
</span><span class="boring">    User {
</span><span class="boring">        _name: name, // field init shorthand(shortens: `name: name,`)
</span><span class="boring">        scores,
</span><span class="boring">        new: true,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Entire struct must be mutable. Individual fields can't be mutable.
</span><span class="boring">    let mut zim = add_user(String::from(&quot;Invader Zim&quot;), Scores(0, 3.6, 9));
</span><span class="boring">    let gir = User {
</span><span class="boring">        _name: String::from(&quot;Gir&quot;),
</span><span class="boring">        ..zim // struct update syntax.
</span><span class="boring">    };
</span><span class="boring">    zim.new = false; // Updating a value
</span><span class="boring">    dbg!(gir.scores.2);
</span><span class="boring">    // dbg!(zim.scores.2); // Error!
</span>    dbg!(zim.new);
<span class="boring">
</span><span class="boring">    // Printing an entire struct
</span><span class="boring">    // println!(&quot;{:?}&quot;, gir); // cannot format with {:?}
</span><span class="boring">    // println!(&quot;{gir}&quot;); // cannot format with default formatter
</span><span class="boring">
</span><span class="boring">    dbg!(gir); // cannot format with {:?}
</span><span class="boring">}
</span><span class="boring">// ANCHOR: all
</span></code></pre></pre>
<ul>
<li>Structs can't be formatted with default formatter or <code>{:?}</code> since Display &amp;
Debug traits both aren't implemented for our struct.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// ANCHOR: all
</span><span class="boring">
</span><span class="boring">// We use tuple structs when we want to give names to tuples
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct Scores(i32, f32, u32);
</span><span class="boring">
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct User {
</span><span class="boring">    _name: String,  // Can't use &quot;str&quot; here
</span><span class="boring">    scores: Scores, // Another struct
</span><span class="boring">    new: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn add_user(name: String, scores: Scores) -&gt; User {
</span><span class="boring">    User {
</span><span class="boring">        _name: name, // field init shorthand(shortens: `name: name,`)
</span><span class="boring">        scores,
</span><span class="boring">        new: true,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Entire struct must be mutable. Individual fields can't be mutable.
</span><span class="boring">    let mut zim = add_user(String::from(&quot;Invader Zim&quot;), Scores(0, 3.6, 9));
</span><span class="boring">    let gir = User {
</span><span class="boring">        _name: String::from(&quot;Gir&quot;),
</span><span class="boring">        ..zim // struct update syntax.
</span><span class="boring">    };
</span><span class="boring">    zim.new = false; // Updating a value
</span><span class="boring">    dbg!(gir.scores.2);
</span><span class="boring">    // dbg!(zim.scores.2); // Error!
</span><span class="boring">    dbg!(zim.new);
</span><span class="boring">
</span>    // Printing an entire struct
    // println!(&quot;{:?}&quot;, gir); // cannot format with {:?}
    // println!(&quot;{gir}&quot;); // cannot format with default formatter
<span class="boring">
</span><span class="boring">    dbg!(gir); // cannot format with {:?}
</span><span class="boring">}
</span><span class="boring">// ANCHOR: all
</span></code></pre></pre>
<ul>
<li>But we added <code>#[derive(Debug)]</code> on top of both the structs. Rust provides
more &quot;derivable&quot;(To use with <code>derive</code> attribute) traits.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// ANCHOR: all
</span><span class="boring">
</span><span class="boring">// We use tuple structs when we want to give names to tuples
</span>#[derive(Debug)] // To print with dbg!
struct Scores(i32, f32, u32);
<span class="boring">
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct User {
</span><span class="boring">    _name: String,  // Can't use &quot;str&quot; here
</span><span class="boring">    scores: Scores, // Another struct
</span><span class="boring">    new: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn add_user(name: String, scores: Scores) -&gt; User {
</span><span class="boring">    User {
</span><span class="boring">        _name: name, // field init shorthand(shortens: `name: name,`)
</span><span class="boring">        scores,
</span><span class="boring">        new: true,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Entire struct must be mutable. Individual fields can't be mutable.
</span><span class="boring">    let mut zim = add_user(String::from(&quot;Invader Zim&quot;), Scores(0, 3.6, 9));
</span><span class="boring">    let gir = User {
</span><span class="boring">        _name: String::from(&quot;Gir&quot;),
</span><span class="boring">        ..zim // struct update syntax.
</span><span class="boring">    };
</span><span class="boring">    zim.new = false; // Updating a value
</span><span class="boring">    dbg!(gir.scores.2);
</span><span class="boring">    // dbg!(zim.scores.2); // Error!
</span><span class="boring">    dbg!(zim.new);
</span><span class="boring">
</span><span class="boring">    // Printing an entire struct
</span><span class="boring">    // println!(&quot;{:?}&quot;, gir); // cannot format with {:?}
</span><span class="boring">    // println!(&quot;{gir}&quot;); // cannot format with default formatter
</span><span class="boring">
</span><span class="boring">    dbg!(gir); // cannot format with {:?}
</span><span class="boring">}
</span><span class="boring">// ANCHOR: all
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// ANCHOR: all
</span><span class="boring">
</span><span class="boring">// We use tuple structs when we want to give names to tuples
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct Scores(i32, f32, u32);
</span><span class="boring">
</span>#[derive(Debug)] // To print with dbg!
struct User {
<span class="boring">    _name: String,  // Can't use &quot;str&quot; here
</span><span class="boring">    scores: Scores, // Another struct
</span><span class="boring">    new: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn add_user(name: String, scores: Scores) -&gt; User {
</span><span class="boring">    User {
</span><span class="boring">        _name: name, // field init shorthand(shortens: `name: name,`)
</span><span class="boring">        scores,
</span><span class="boring">        new: true,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Entire struct must be mutable. Individual fields can't be mutable.
</span><span class="boring">    let mut zim = add_user(String::from(&quot;Invader Zim&quot;), Scores(0, 3.6, 9));
</span><span class="boring">    let gir = User {
</span><span class="boring">        _name: String::from(&quot;Gir&quot;),
</span><span class="boring">        ..zim // struct update syntax.
</span><span class="boring">    };
</span><span class="boring">    zim.new = false; // Updating a value
</span><span class="boring">    dbg!(gir.scores.2);
</span><span class="boring">    // dbg!(zim.scores.2); // Error!
</span><span class="boring">    dbg!(zim.new);
</span><span class="boring">
</span><span class="boring">    // Printing an entire struct
</span><span class="boring">    // println!(&quot;{:?}&quot;, gir); // cannot format with {:?}
</span><span class="boring">    // println!(&quot;{gir}&quot;); // cannot format with default formatter
</span><span class="boring">
</span><span class="boring">    dbg!(gir); // cannot format with {:?}
</span><span class="boring">}
</span><span class="boring">// ANCHOR: all
</span></code></pre></pre>
<ul>
<li>So we can print the structs with <code>dbg!</code> or using <code>{:?}</code> in <code>println!</code>. It prints to the <code>stderr</code> as opposed to <code>println!</code> which prints to <code>stdout</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// ANCHOR: all
</span><span class="boring">
</span><span class="boring">// We use tuple structs when we want to give names to tuples
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct Scores(i32, f32, u32);
</span><span class="boring">
</span><span class="boring">#[derive(Debug)] // To print with dbg!
</span><span class="boring">struct User {
</span><span class="boring">    _name: String,  // Can't use &quot;str&quot; here
</span><span class="boring">    scores: Scores, // Another struct
</span><span class="boring">    new: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn add_user(name: String, scores: Scores) -&gt; User {
</span><span class="boring">    User {
</span><span class="boring">        _name: name, // field init shorthand(shortens: `name: name,`)
</span><span class="boring">        scores,
</span><span class="boring">        new: true,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    // Entire struct must be mutable. Individual fields can't be mutable.
</span><span class="boring">    let mut zim = add_user(String::from(&quot;Invader Zim&quot;), Scores(0, 3.6, 9));
</span><span class="boring">    let gir = User {
</span><span class="boring">        _name: String::from(&quot;Gir&quot;),
</span><span class="boring">        ..zim // struct update syntax.
</span><span class="boring">    };
</span><span class="boring">    zim.new = false; // Updating a value
</span><span class="boring">    dbg!(gir.scores.2);
</span><span class="boring">    // dbg!(zim.scores.2); // Error!
</span><span class="boring">    dbg!(zim.new);
</span><span class="boring">
</span><span class="boring">    // Printing an entire struct
</span><span class="boring">    // println!(&quot;{:?}&quot;, gir); // cannot format with {:?}
</span><span class="boring">    // println!(&quot;{gir}&quot;); // cannot format with default formatter
</span><span class="boring">
</span>    dbg!(gir); // cannot format with {:?}
<span class="boring">}
</span><span class="boring">// ANCHOR: all
</span></code></pre></pre>
<ul>
<li>
<p>We can also use <code>{:#?}</code> for pretty print</p>
</li>
<li>
<p>There are <a href="https://doc.rust-lang.org/reference/attributes.html">more attributes other than <code>derive</code></a></p>
</li>
<li>
<p>Unit-like structs can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
</code></pre></pre>
<h2 id="ownership-of-struct-data"><a class="header" href="#ownership-of-struct-data">Ownership of Struct Data</a></h2>
<ul>
<li>
<p>In the User struct definition we used the owned String type rather than the <code>&amp;str</code> string slice type. This is a deliberate choice because we want each instance of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.</p>
</li>
<li>
<p>It’s also possible for structs to store references to data owned by something else, but to do so requires the use of lifetimes, a Rust feature that we’ll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is. Let’s say you try to store a reference in a struct without specifying lifetimes, like the following; this won’t work:</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust">struct User {
    active: bool,
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre></pre>
<p>The compiler will complain that it needs lifetime specifiers:</p>
<details>
<summary>Error</summary>
<pre><code class="language-console">   Compiling l02-structs-lifetimes v0.1.0 (/home/zim/github/the_rust_book/listings/05_using_structs_to_structure_related_data/l02-structs-lifetimes)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:15
  |
4 |     username: &amp;str,
  |               ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
2 ~ struct User&lt;'a&gt; {
3 |     active: bool,
4 ~     username: &amp;'a str,
  |

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:12
  |
5 |     email: &amp;str,
  |            ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
2 ~ struct User&lt;'a&gt; {
3 |     active: bool,
4 |     username: &amp;str,
5 ~     email: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `l02-structs-lifetimes` due to 2 previous errors
</code></pre>
</details>
<h2 id="method-syntax"><a class="header" href="#method-syntax">Method Syntax</a></h2>
<ul>
<li>First parameter is always self, which represents the instance of the struct the method is being called on.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        other.width &lt; self.width &amp;&amp; other.height &lt; self.height
    }
}

impl Rectangle {
    // Associated function
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            height: size,
            width: size,
        }
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    let rect2 = Rectangle { ..rect1 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );

    if rect1.width() {
        dbg!(rect1.width);
    }

    dbg!(rect1.can_hold(&amp;rect2));

    dbg!(Rectangle::square(5));
}
</code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">   Compiling l03-method-syntax v0.1.0 (/home/zim/github/the_rust_book/listings/05_using_structs_to_structure_related_data/l03-method-syntax)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/l03-method-syntax`
The area of the rectangle is 1500 square pixels.
[src/main.rs:33] rect1.width = 30
</code></pre>
</details>
<ul>
<li>
<p>In the signature for area, we use <code>&amp;self</code> instead of rectangle: <code>&amp;Rectangle</code>. The <code>&amp;self</code> is actually short for self: <code>&amp;Self.</code> Within an <code>impl</code> block, the type Self is an alias for the type that the <code>impl</code> block is for. Methods must have a parameter named self of type Self for their first parameter, so Rust lets you abbreviate this with only the name self in the first parameter spot. Note that we still need to use the &amp; in front of the self shorthand to indicate this method borrows the Self instance, just as we did in rectangle: <code>&amp;Rectangle</code> Methods can take ownership of self, borrow self immutably as we’ve done here, or borrow self mutably, just as they can any other parameter.</p>
</li>
<li>
<p>If we wanted to change the instance that we’ve called the method on as part of what the method does, we’d use <code>&amp;mut</code> self as the first parameter. Having a method that takes ownership of the instance by using just self as the first parameter is rare; this technique is usually used when the method transforms self into something else and you want to prevent the caller from using the original instance after the transformation.</p>
</li>
<li>
<p>We can use the same name for the method &amp; struct field.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn area(&amp;self) -&gt; u32 {
</span><span class="boring">        self.width * self.height
</span><span class="boring">    }
</span><span class="boring">
</span>    fn width(&amp;self) -&gt; bool {
        self.width &gt; 0
    }
<span class="boring">
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        other.width &lt; self.width &amp;&amp; other.height &lt; self.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    // Associated function
</span><span class="boring">    fn square(size: u32) -&gt; Rectangle {
</span><span class="boring">        Rectangle {
</span><span class="boring">            height: size,
</span><span class="boring">            width: size,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let rect2 = Rectangle { ..rect1 };
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The area of the rectangle is {} square pixels.&quot;,
</span><span class="boring">        rect1.area()
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    if rect1.width() {
</span><span class="boring">        dbg!(rect1.width);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    dbg!(rect1.can_hold(&amp;rect2));
</span><span class="boring">
</span><span class="boring">    dbg!(Rectangle::square(5));
</span><span class="boring">}
</span></code></pre></pre>
<ul>
<li>Call method with <code>.width()</code> and field with just <code>.width</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn area(&amp;self) -&gt; u32 {
</span><span class="boring">        self.width * self.height
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn width(&amp;self) -&gt; bool {
</span><span class="boring">        self.width &gt; 0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        other.width &lt; self.width &amp;&amp; other.height &lt; self.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    // Associated function
</span><span class="boring">    fn square(size: u32) -&gt; Rectangle {
</span><span class="boring">        Rectangle {
</span><span class="boring">            height: size,
</span><span class="boring">            width: size,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let rect2 = Rectangle { ..rect1 };
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The area of the rectangle is {} square pixels.&quot;,
</span><span class="boring">        rect1.area()
</span><span class="boring">    );
</span><span class="boring">
</span>    if rect1.width() {
        dbg!(rect1.width);
    }
<span class="boring">
</span><span class="boring">    dbg!(rect1.can_hold(&amp;rect2));
</span><span class="boring">
</span><span class="boring">    dbg!(Rectangle::square(5));
</span><span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p>In C and C++, two different operators are used for calling methods. If <code>object</code> is a pointer, <code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
</li>
<li>
<p>Rust doesn’t have an equivalent to the -&gt; operator; instead, Rust has a feature called automatic referencing and dereferencing. Calling methods is one of the few places in Rust that has this behavior.</p>
</li>
<li>
<p>Associated functions that aren’t methods are often used for constructors that will return a new instance of the struct.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn area(&amp;self) -&gt; u32 {
</span><span class="boring">        self.width * self.height
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn width(&amp;self) -&gt; bool {
</span><span class="boring">        self.width &gt; 0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        other.width &lt; self.width &amp;&amp; other.height &lt; self.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    // Associated function
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            height: size,
            width: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let rect2 = Rectangle { ..rect1 };
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The area of the rectangle is {} square pixels.&quot;,
</span><span class="boring">        rect1.area()
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    if rect1.width() {
</span><span class="boring">        dbg!(rect1.width);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    dbg!(rect1.can_hold(&amp;rect2));
</span><span class="boring">
</span><span class="boring">    dbg!(Rectangle::square(5));
</span><span class="boring">}
</span></code></pre></pre>
<ul>
<li>Called with <code>::</code> syntax</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn area(&amp;self) -&gt; u32 {
</span><span class="boring">        self.width * self.height
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn width(&amp;self) -&gt; bool {
</span><span class="boring">        self.width &gt; 0
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        other.width &lt; self.width &amp;&amp; other.height &lt; self.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    // Associated function
</span><span class="boring">    fn square(size: u32) -&gt; Rectangle {
</span><span class="boring">        Rectangle {
</span><span class="boring">            height: size,
</span><span class="boring">            width: size,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let rect2 = Rectangle { ..rect1 };
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;The area of the rectangle is {} square pixels.&quot;,
</span><span class="boring">        rect1.area()
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    if rect1.width() {
</span><span class="boring">        dbg!(rect1.width);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    dbg!(rect1.can_hold(&amp;rect2));
</span><span class="boring">
</span>    dbg!(Rectangle::square(5));
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>We can have our associated function in it's own impl block. Each struct is allowed to have multiple impl blocks. There’s no reason to separate these methods into multiple impl blocks here, but this is valid syntax.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enums-and-pattern-matching"><a class="header" href="#enums-and-pattern-matching">Enums And Pattern Matching</a></h1>
<p>Enums give you a way of saying a value is one of a possible set of values.</p>
<p>An IpAddrKind enumeration listing the possible kinds an IP address can be, V4 and V6. These are the variants of the enum:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[allow(unused_variables)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">fn main() {
</span>    enum IpAddr {
        V4(u8, u8, u8, u8),
        V6(String),
    }

    let home = IpAddr::V4(127, 0, 0, 1);

    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">
</span><span class="boring">    enum Value {
</span><span class="boring">        Nothing,
</span><span class="boring">        Something { field: i32 },
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p>The name of each enum variant that we define also becomes a function that constructs an instance of the enum. That is, IpAddr::V6() is a function call that takes a String argument and returns an instance of the IpAddr type. We automatically get this constructor function defined as a result of defining the enum.</p>
<p>You can also do some funky stuff. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[allow(unused_variables)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">fn main() {
</span><span class="boring">    enum IpAddr {
</span><span class="boring">        V4(u8, u8, u8, u8),
</span><span class="boring">        V6(String),
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let home = IpAddr::V4(127, 0, 0, 1);
</span><span class="boring">
</span><span class="boring">    let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
</span><span class="boring">
</span>    enum Value {
        Nothing,
        Something { field: i32 },
    }
<span class="boring">}
</span></code></pre></pre>
<!-- TODO: Understand the use case for the `Something` in above code  -->
<p>Here, <code>Nothing</code> isn't even a unit struct. It has no data associated with it at all.</p>
<p>We’re also able to define methods on enums.</p>
<h2 id="null"><a class="header" href="#null">Null</a></h2>
<p>The problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.</p>
<p>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</p>
<p>The problem isn’t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is Option<T>, and it is <a href="https://doc.rust-lang.org/std/option/enum.Option.html">defined by the standard library</a> as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}
</span></code></pre></pre>
<p>The <T> syntax represents a generic type.</p>
<!-- TODO: Add a good enum(with "match") example covering a tonne of fun -->
<h2 id="if-let"><a class="header" href="#if-let">if let</a></h2>
<p>You can think of if let as syntax sugar for a match that runs code when the value matches one pattern and then ignores all other values.</p>
<ul>
<li>We can include an else with an if let.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let cash = Some(69);
    if let Some(69) = cash {
        println!(&quot;Yay!&quot;);
    } else {
        println!(&quot;Missed it!&quot;);
    }
}
</code></pre></pre>
<details>
<summary>Output</summary>
<pre><code class="language-console">    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/if-let`
Yay!
</code></pre>
</details>
<!-- TODO -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-growing-projects-with-packages-crates-and-modules"><a class="header" href="#managing-growing-projects-with-packages-crates-and-modules">Managing Growing Projects With Packages Crates And Modules</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-collections"><a class="header" href="#common-collections">Common Collections</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types-traits-and-lifetimes"><a class="header" href="#generic-types-traits-and-lifetimes">Generic Types Traits And Lifetimes</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-automated-tests"><a class="header" href="#writing-automated-tests">Writing Automated Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="an-io-project"><a class="header" href="#an-io-project">An Io Project</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-language-features"><a class="header" href="#functional-language-features">Functional Language Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-about-cargo-and-cratesio"><a class="header" href="#more-about-cargo-and-cratesio">More About Cargo And Crates.io</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart Pointers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fearless-concurrency"><a class="header" href="#fearless-concurrency">Fearless Concurrency</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-oriented-programming-features-of-rust"><a class="header" href="#object-oriented-programming-features-of-rust">Object Oriented Programming Features Of Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns-and-matching"><a class="header" href="#patterns-and-matching">Patterns And Matching</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-project"><a class="header" href="#final-project">Final Project</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
